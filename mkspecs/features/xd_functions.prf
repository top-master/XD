# --------------------------------------
# This file defines few useful functions
# --------------------------------------

xd_command_count = 0

defineReplace(xd_suffix) {
    r = $$1

    # Suffixes with build-type's mark (like "d" for debug).
    r = $$r$$qtPlatformTargetSuffix()

    # Suffixes with system extension.
    win32: r = $${r}.dll
    else:  r = $${r}.so
    return($$r)
}

defineReplace(xd_module) {
    unset(name)
    name = $$lower($$1)

    # Map "$$QT" config-entries to real file-names.
    !isEmpty(QT.$${name}.module) {
        name = $$eval(QT.$${name}.module)
    } else {
        equals(name, testlib) {
            name = test
        }

        # Make first-letter upper-case (while \U RegEx is not supported).
        unset(letter)
        letter = $$name
        letter ~= s|^(.).*|\\1|g
        name ~= s|^.(.*)|\\1|g
        name = $$upper("$$letter")$$name

        # Prefix with XD versio
        name = Qt$$QT_MAJOR_VERSION$$name
    }

    # Suffix build-type's sign.
    return( $$xd_suffix($$name) )
}

#xd_prebuild(prefix, command)
defineTest(xd_prebuild) {
    #generate target name with number
    xd_command_count = $$num_add($$xd_command_count, 1)
    name = $$1$$xd_command_count
    # Append command (without surrounding by spaces).
    eval( $${name}.commands += (\$\$2) );
    #the qmake generated "MakeFile" should contain "first"
    #   and we depend that on new command
    !contains( first.depends, $$name ) {
        !isEmpty(first.depends): first.depends += \\$$escape_expand(\\n)
        first.depends += $$name
    }

    QMAKE_EXTRA_TARGETS *= first $$name

    export(xd_command_count)
    export($${name}.commands)
    export(first.depends)
    export(QMAKE_EXTRA_TARGETS)

    #eval( warning(xd_push_command: $${name}.commands += \$\${$${name}.commands}) )
}
#xd_postbuild(command)
defineTest(xd_postbuild) {
    !isEmpty(QMAKE_POST_LINK): QMAKE_POST_LINK = $$QMAKE_POST_LINK$$escape_expand(\\n\\t)
    QMAKE_POST_LINK = $${QMAKE_POST_LINK}$$shell_quote(-$$1)

    export(QMAKE_POST_LINK)
}
#xd_escape(path)
#   resolves path like built-in functions (i.e. counts input relative to $$PWD)
defineReplace(xd_escape) {
    1 = $$absolute_path($$1)
    #using "shell_path()" to correct path depending on platform
    #   escaping quotes and backslashes for file paths
    1 = $$shell_path($$1)
    return(\"$$1\")
}

#copyFile(source, destination)
#   this will both copy and rename "source" to "destination", However like "copy_file()":
#       if "destination" is path to existing directory or ends with slash (i.e. "/" or "\\"),
#       will just copy to existing "destination" directory without any rename
#
#   note: this is executed before build, but after qmake did exit
#       so use "copy_file(...)" instead if the output file is required in qmake script
#       like for example if "write_file(...)" is called on the output...
defineTest(copyFile) {
    #note that "$(COPY_FILE)" is generated by qmake from "$$QMAKE_COPY_FILE"
    xd_prebuild(xd_copyfile, $(COPY_FILE) $$xd_escape($$1) $$xd_escape($$2) || echo copyFile-failed)
}

#copyFileLater(source, destination = $(DESTDIR))
#   note: this is executed after build is done, hence the name copy-later
defineTest(copyFileLater) {
    destDir = $$2
    isEmpty(destDir): destDir = $(DESTDIR)
    #append copy command
    xd_postbuild($(COPY_FILE) $$xd_escape($$1) $$xd_escape($$destDir) || echo copyFileLater-failed)

    #!build_pass:warning(copyFile: $$1 to: $$destDir)
}

#copyDir(source, destination)
defineTest(copyDir) {
    xd_prebuild(xd_copydir, $(COPY_DIR) $$xd_escape($$1) $$xd_escape($$2) || echo copyDir-failed)
}
#copyDirLater(source, destination = $(DESTDIR))
#   note: this is executed after build is done, hence the name copy-later
defineTest(copyDirLater) {
    destDir = $$2
    isEmpty(destDir): destDir = $(DESTDIR)
    #append copy command
    xd_postbuild($(COPY_DIR) $$xd_escape($$1) $$xd_escape($$destDir) || echo copyDirLater-failed)

    #!build_pass:warning(copyFile: $$1 to: $$destDir)
}

#makeDir(destination)
defineTest(makeDir) {
    xd_prebuild(xd_makedir, $(MKDIR) $$xd_escape($$1) || echo makeDir-failed: \"$$1\")
}
defineTest(makeDirLater) {
    xd_postbuild( $(MKDIR) $$xd_escape($$1) || echo makeDirLater-failed )
    #!build_pass:warning(makeDirLater: $$1)
}

defineTest(deleteFile) {
    xd_prebuild(xd_delfile, $(DEL_FILE) $$xd_escape($$1) || echo deleteFile-failed)
}
defineTest(deleteFileLater) {
    xd_postbuild( $(DEL_FILE) $$xd_escape($$1) || echo deleteFileLater-failed )
    #!build_pass:warning(deleteFileLater: $$1)
}
defineTest(deleteDir) {
    xd_prebuild(xd_delfile, $(DEL_DIR) $$xd_escape($$1) || echo deleteDir-failed)
}
defineTest(deleteDirLater) {
    xd_postbuild( $(DEL_DIR) $$xd_escape($$1) || echo deleteDirLater-failed )
    #!build_pass:warning(deleteFileLater: $$1)
}

# qmakeRun(qmake-script-file-path-to-run, command-line)
#
# Executes given qmake-script, before caller project is built.
#
# note that inside the script runned by this method,
# the $$OUT_PWD will be same as `qmakeRun(...)` caller project,
# because there is the "Makefile" that executes our custom qmake.
#
defineTest(qmakeRun) {
    xd_prebuild( xd_qmakeRun, $(QMAKE) $$xd_escape($$1) -r -spec \"$$shell_path($$QMAKESPEC)\" $$2 )
}

# Same as `qmakeRun(...)`, but executes after caller project is built.
defineTest(qmakeLater) {
    xd_postbuild( $(QMAKE) $$xd_escape($$1) -r -spec \"$$shell_path($$QMAKESPEC)\" $$2 )
    #!build_pass:warning(qmakeLater: $$1)
}


# copyModule(name, [destinationDirectory = $$DESTDIR]
defineTest(copyModule) {
    # Create destination directory and copy module there
    isEmpty(2) {
        2 = $$shadowed( $$DESTDIR ) # make absolute for later copy calls
    }
    mkpath($$2)
    copy_file($$[QT_INSTALL_BINS]/$$xd_module($$1), $$2/)
}
defineTest(copyModules) {
    unset(list)
    for(name, QT) {
        list *= $$name
    }
    for(name, list) {
        copyModule($$name)
    }
}

# copyPlugin(type, name, [destinationDirectory = $$DESTDIR])
defineTest(copyPlugin) {
    unset(path)
    path = $$[QT_INSTALL_PLUGINS]/$$1
    # Append name
    path = $${path}/q$$xd_suffix($$2)
    # Create destination directory and copy plugin there
    isEmpty(3) {
        3 = $$shadowed( $$DESTDIR )/$$1 # make absolute for later copy calls
    }
    mkpath($$3)
    copy_file($$path, $$3/)
}

# copyPlatformDriver(name, [destinationDirectory])
defineTest(copyPlatformDriver) {
    copyPlugin( platforms, $$1, $$2 )
}
# copySqlDriver(name, [destinationDirectory])
defineTest(copySqlDriver) {
    copyPlugin( sqldrivers, $$1, $$2 )
}
defineTest(copyImageDriver) {
    copyPlugin( imageformats, $$1, $$2 )
}
defineTest(copyOpenSSL) {
    isEmpty(1) {
        1 = $$shadowed( $$DESTDIR ) # make absolute for later copy calls
    }
    mkpath($$1)
    path = "$$[QT_INSTALL_LIBS]/openssl"
    CONFIG(debug, debug|release) {
        path = $${path}/debug
    } else {
        path = $${path}/release
    }
    copy_file($$path/libeay32.dll, $$1/)
    copy_file($$path/ssleay32.dll, $$1/)
}
