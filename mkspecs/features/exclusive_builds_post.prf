
# Ensures already loaded, for `prepareRecursiveTarget(...)`.
load(qt_functions)

contains(TEMPLATE, subdirs) {
    for(build, QMAKE_EXCLUSIVE_BUILDS) {
        prepareRecursiveTarget($$build)
        QMAKE_EXTRA_TARGETS += $$build
    }
} else {
    load(exclusive_builds_target)

    # TRACE/mkspecs QMAKE_DIR_REPLACE: handle suffix, unless already "done".
    QMAKE_DIR_REPLACE *= $$QMAKE_DIR_FIX
    QMAKE_DIR_REPLACE -= $$QMAKE_DIR_REPLACE_DONE

    build_pass|fix_output_dirs {
        for(dir, QMAKE_DIR_REPLACE) {
            QMAKE_DIR_REPLACE_DONE *= $$dir

            # Limit builds to ones that should affect the current $$dir
            builds =
            for(build, $${BUILD_PASS}.builds) {
                # Skips `DESTDIR`, for example if `debug_and_release_target` is NOT set in `CONFIG`.
                equals(dir, DESTDIR) {
                    !$$join($${build}.exclusive, _and_)_target: \
                        next()
                }

                builds += $$build
            }

            isEmpty(builds): \
                next()

            full_dir_affix = $$affixFromBuilds(builds)

            isEmpty($$dir)|isEqual($$dir, .) {
                # Use affix directly
                $$dir = $$full_dir_affix
                next()
            }

            contains(QMAKE_DIR_FIX, $$dir)|contains(QMAKE_DIR_REPLACE_SANE, $$dir) {
                # Suffix output dir
                $$dir = $$clean_path($$eval($$dir)/$$full_dir_affix)
            } else {
                # "Compatibility mode" with QTBUG-491
                for(build, builds) {
                    build_affix = $$eval($${build}.dir_affix)
                    for(exclusive, $${build}.exclusive) {
                        equals(exclusive, $$build): \
                            next()

                        exclusive_affix = $$eval($${exclusive}.dir_affix)
                        contains($$dir, .*$${exclusive_affix}.*) {
                            # TRACE/mkspecs QMAKE_DIR_REPLACE: never replace parts of user's paths,
                            # instead by default warns about paths containing another build-type's exclusive ID.
                            compat_verbose: warning(QMAKE_DIR_REPLACE: $$dir contains: \"$${exclusive_affix}\" but XD will NOT replace it with: $${build_affix})
                        }
                    }

                    # Append (as subdir or as suffix)
                    !build_pass {
                        dir_affix = $$eval($${build}.dir_affix)
                        !contains($$dir, .*$${dir_affix}.*) {
                            contains($$dir, .*/$) {
                                # Subdir
                                $$dir = $$eval($$dir)$$dir_affix
                            } else {
                                # Suffix
                                $$dir = $$eval($$dir)-$${dir_affix}
                            }
                        }
                    }
                }
            }
        }
    }
}
